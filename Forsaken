local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local VIM = game:GetService("VirtualInputManager")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local name = LocalPlayer.Name
local display = LocalPlayer.DisplayName

-- Cached references
local MapIngame = Workspace:WaitForChild("Map"):WaitForChild("Ingame")
local SurvivorsFolder = Workspace:WaitForChild("Players"):WaitForChild("Survivors")
local KillersFolder = Workspace:WaitForChild("Players"):WaitForChild("Killers")
local RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

-- Global variables
local isHighlightActive = false
local hideplayerbar = false
local toolhighlightActive = false
local isCorruptNatureEspActive = false
local isSurvivorUtilEspActive = false
local isSurvivorHighlightActive = false
local isKillerHighlightActive = false
local stam = false
local Do1x1PopupsLoop = false
local slashEnabled = false
local daggerEnabled = false
local walkspeedEnabled = false
local gashingWoundEnabled = false
local isNoclipActive = false

-- Debounce variables
local teleportDebounce = false
local DEBOUNCE_TIME = 0.5
local abilityDebounce = false
local ABILITY_DEBOUNCE_TIME = 1.0

-- Store connections for cleanup
local connections = {}

-- Automatically set device to Mobile
RemoteEvent:FireServer("SetDevice", "Mobile")

local GUI = Rayfield:CreateWindow({
   Name = "Decay || Forsaken",
   Icon = 0,
   LoadingTitle = "Credits to Apple Ware!",
   LoadingSubtitle = "Welcome, " .. display .. " (" .. name .. ")",
   Theme = "Default",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil,
      FileName = "Decay"
   },
   Discord = {
      Enabled = true,
      Invite = "https://discord.gg/Cdb2YE33sa",
      RememberJoins = true
   },
   KeySystem = true,
   KeySettings = {
      Title = "Decay Key System",
      Subtitle = "join",
      Note = "Join discord for key https://discord.gg/Cdb2YE33sa",
      FileName = "Decaykey",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"Blocky69"}
   }
})

-- Shared Utility Functions
local function findKiller()
    local killerCharacter = KillersFolder:GetChildren()[1]
    if not killerCharacter then return nil end
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character == killerCharacter and player.Character:FindFirstChild("HumanoidRootPart") then
            return player
        end
    end
    return nil
end

local function enableNoclip(character)
    if not character or not character:FindFirstChild("HumanoidRootPart") or isNoclipActive then
        return false
    end
    isNoclipActive = true
    local humanoidParts = {
        "HumanoidRootPart",
        "Head",
        "UpperTorso",
        "LowerTorso",
        "LeftUpperArm",
        "LeftLowerArm",
        "LeftHand",
        "RightUpperArm",
        "RightLowerArm",
        "RightHand",
        "LeftUpperLeg",
        "LeftLowerLeg",
        "LeftFoot",
        "RightUpperLeg",
        "RightLowerLeg",
        "RightFoot"
    }
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and not table.find(humanoidParts, part.Name) then
            part.CanCollide = false
        end
    end
    return true
end

local function disableNoclip(character)
    if not character or not character:FindFirstChild("HumanoidRootPart") or not isNoclipActive then
        return false
    end
    isNoclipActive = false
    local humanoidParts = {
        "HumanoidRootPart",
        "Head",
        "UpperTorso",
        "LowerTorso",
        "LeftUpperArm",
        "LeftLowerArm",
        "LeftHand",
        "RightUpperArm",
        "RightLowerArm",
        "RightHand",
        "LeftUpperLeg",
        "LeftLowerLeg",
        "LeftFoot",
        "RightUpperLeg",
        "RightLowerLeg",
        "RightFoot"
    }
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and not table.find(humanoidParts, part.Name) then
            part.CanCollide = true
        end
    end
    return true
end

local function findClosestSurvivor()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        warn("Player character or HumanoidRootPart not found!")
        return nil
    end

    local playerPos = character.HumanoidRootPart.Position
    local closestSurvivor = nil
    local minDistance = math.huge

    for _, survivorCharacter in ipairs(SurvivorsFolder:GetChildren()) do
        local survivorPlayer = Players:GetPlayerFromCharacter(survivorCharacter)
        if survivorPlayer and survivorPlayer ~= LocalPlayer and survivorCharacter:FindFirstChild("HumanoidRootPart") then
            local survivorPos = survivorCharacter.HumanoidRootPart.Position
            local distance = (playerPos - survivorPos).Magnitude
            if distance < minDistance then
                minDistance = distance
                closestSurvivor = survivorPlayer
            end
        end
    end

    if not closestSurvivor then
        warn("No valid survivors found!")
    end
    return closestSurvivor
end

-- GashingWound Ability Functions
local function useGashingWoundAbility()
    if abilityDebounce then return false end
    local character = LocalPlayer.Character
    if not character or character.Name ~= "Jason" then
        warn("Player character is not Jason!")
        return false
    end
    abilityDebounce = true
    task.defer(function() task.wait(ABILITY_DEBOUNCE_TIME) abilityDebounce = false end)
    local args = { "UseActorAbility", "GashingWound" }
    if RemoteEvent:IsA("RemoteEvent") then
        RemoteEvent:FireServer(unpack(args))
        print("Instantly used GashingWound ability upon teleport!")
        return true
    else
        Rayfield:Notify{Title = "Error", Content = "RemoteEvent not found!", Duration = 5}
        return false
    end
end

local function teleportCloseToSurvivorGashingWound()
    if not gashingWoundEnabled or teleportDebounce then return end
    teleportDebounce = true
    task.defer(function() task.wait(DEBOUNCE_TIME) teleportDebounce = false end)

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or character.Name ~= "Jason" then
        warn("Player character or HumanoidRootPart not found or not Jason!")
        return
    end

    local playerHumanoidRootPart = character.HumanoidRootPart
    local survivor = findClosestSurvivor()
    if not survivor or not survivor.Character or not survivor.Character:FindFirstChild("HumanoidRootPart") then
        warn("Survivor or survivor character not found!")
        return
    end

    if not useGashingWoundAbility() then return end
    task.wait(0.1)

    enableNoclip(character)

    local survivorHumanoidRootPart = survivor.Character.HumanoidRootPart
    local offset = CFrame.new(0, 0, 0.25)
    local survivorPos = survivorHumanoidRootPart.Position
    local closePos = survivorHumanoidRootPart.CFrame * offset
    local lookAtCFrame = CFrame.new(closePos.Position, survivorPos)
    playerHumanoidRootPart.CFrame = lookAtCFrame
    print("Teleported 0.25 studs behind the closest survivor and facing them!")

    local elapsedTime = 0
    local duration = 1
    if connections.gashingWoundConnection then
        connections.gashingWoundConnection:Disconnect()
    end
    connections.gashingWoundConnection = RunService.Heartbeat:Connect(function(deltaTime)
        elapsedTime = elapsedTime + deltaTime
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            if connections.gashingWoundConnection then
                connections.gashingWoundConnection:Disconnect()
                connections.gashingWoundConnection = nil
            end
            return
        end

        -- Ensure no-clip is active for non-humanoid parts during the follow
        if not isNoclipActive then
            enableNoclip(character)
        end

        if elapsedTime >= duration then
            if connections.gashingWoundConnection then
                connections.gashingWoundConnection:Disconnect()
                connections.gashingWoundConnection = nil
            end
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Finished following survivor after 1 second!")
            return
        end

        if not survivor.Character or not survivor.Character:FindFirstChild("HumanoidRootPart") then
            warn("Survivor's HumanoidRootPart lost during follow!")
            if connections.gashingWoundConnection then
                connections.gashingWoundConnection:Disconnect()
                connections.gashingWoundConnection = nil
            end
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Stopped following due to survivor loss!")
            return
        end

        survivorHumanoidRootPart = survivor.Character.HumanoidRootPart
        survivorPos = survivorHumanoidRootPart.Position
        closePos = survivorHumanoidRootPart.CFrame * offset
        lookAtCFrame = CFrame.new(closePos.Position, survivorPos)
        playerHumanoidRootPart.CFrame = lookAtCFrame
    end)
end

-- Slash Ability Functions
local function useSlashAbility()
    if abilityDebounce then return false end
    local character = LocalPlayer.Character
    if not character or character.Name ~= "Shedletsky" then return false end
    abilityDebounce = true
    task.defer(function() task.wait(ABILITY_DEBOUNCE_TIME) abilityDebounce = false end)
    local args = { "UseActorAbility", "Slash" }
    if RemoteEvent:IsA("RemoteEvent") then
        RemoteEvent:FireServer(unpack(args))
        print("Used Slash ability! Waiting for wind-up...")
        return true
    else
        Rayfield:Notify{Title = "Error", Content = "RemoteEvent not found!", Duration = 5}
        return false
    end
end

local function slashAndTeleport()
    if not slashEnabled or teleportDebounce then return end
    teleportDebounce = true
    task.defer(function() task.wait(DEBOUNCE_TIME) teleportDebounce = false end)

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        warn("Player character not found!")
        return
    end

    local playerHumanoidRootPart = character.HumanoidRootPart
    local originalCFrame = playerHumanoidRootPart.CFrame

    if not useSlashAbility() then return end
    task.wait(0.3)
    print("Wind-up complete! Teleporting in front of killer...")

    local killer = findKiller()
    if not killer or not killer.Character or not killer.Character:FindFirstChild("HumanoidRootPart") then
        warn("Killer or killer character not found!")
        return
    end

    local killerHumanoidRootPart = killer.Character.HumanoidRootPart
    enableNoclip(character)

    local forwardOffset = killerHumanoidRootPart.CFrame.LookVector * 0.25
    local intoPos = killerHumanoidRootPart.CFrame + forwardOffset
    playerHumanoidRootPart.CFrame = intoPos
    print("Teleported in front of the killer's position!")

    local elapsedTime = 0
    local strikeTime = 1.0
    if connections.slashConnection then
        connections.slashConnection:Disconnect()
    end
    connections.slashConnection = RunService.Heartbeat:Connect(function(deltaTime)
        elapsedTime = elapsedTime + deltaTime
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            if connections.slashConnection then
                connections.slashConnection:Disconnect()
                connections.slashConnection = nil
            end
            return
        end

        -- Ensure no-clip is active for non-humanoid parts during the follow
        if not isNoclipActive then
            enableNoclip(character)
        end

        if elapsedTime >= strikeTime then
            if connections.slashConnection then
                connections.slashConnection:Disconnect()
                connections.slashConnection = nil
            end
            playerHumanoidRootPart.CFrame = originalCFrame
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Strike completed! Teleported back to original position.")
            return
        end

        if not killer.Character or not killer.Character:FindFirstChild("HumanoidRootPart") then
            warn("Killer's HumanoidRootPart lost during follow!")
            if connections.slashConnection then
                connections.slashConnection:Disconnect()
                connections.slashConnection = nil
            end
            playerHumanoidRootPart.CFrame = originalCFrame
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Teleported back due to killer loss!")
            return
        end

        killerHumanoidRootPart = killer.Character.HumanoidRootPart
        forwardOffset = killerHumanoidRootPart.CFrame.LookVector * 0.25
        playerHumanoidRootPart.CFrame = killerHumanoidRootPart.CFrame + forwardOffset
    end)
end

-- Dagger Ability Functions
local function useDaggerAbility()
    if abilityDebounce then return false end
    local character = LocalPlayer.Character
    if not character or character.Name ~= "TwoTime" then return false end
    abilityDebounce = true
    task.defer(function() task.wait(ABILITY_DEBOUNCE_TIME) abilityDebounce = false end)
    local args = { "UseActorAbility", "Dagger" }
    if RemoteEvent:IsA("RemoteEvent") then
        RemoteEvent:FireServer(unpack(args))
        print("Instantly used Dagger ability upon teleport!")
        return true
    else
        Rayfield:Notify{Title = "Error", Content = "RemoteEvent not found!", Duration = 5}
        return false
    end
end

local function teleportBehindKiller()
    if not daggerEnabled or teleportDebounce then return end
    teleportDebounce = true
    task.defer(function() task.wait(DEBOUNCE_TIME) teleportDebounce = false end)

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        warn("Player character not found!")
        return
    end
    local playerHumanoidRootPart = character.HumanoidRootPart
    local originalCFrame = playerHumanoidRootPart.CFrame
    local killer = findKiller()
    if not killer or not killer.Character or not killer.Character:FindFirstChild("HumanoidRootPart") then
        warn("Killer or killer character not found!")
        return
    end

    if not useDaggerAbility() then return end
    task.wait(0.1)

    local killerHumanoidRootPart = killer.Character.HumanoidRootPart
    local offset = CFrame.new(0, 0, 2)
    local killerPos = killerHumanoidRootPart.Position
    local behindPos = killerHumanoidRootPart.CFrame * offset
    local lookAtCFrame = CFrame.new(behindPos.Position, killerPos)
    playerHumanoidRootPart.CFrame = lookAtCFrame
    print("Teleported 2 studs behind the killer and facing them!")

    enableNoclip(character)

    local elapsedTime = 0
    local duration = 1
    if connections.daggerConnection then
        connections.daggerConnection:Disconnect()
    end
    connections.daggerConnection = RunService.Heartbeat:Connect(function(deltaTime)
        elapsedTime = elapsedTime + deltaTime
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            if connections.daggerConnection then
                connections.daggerConnection:Disconnect()
                connections.daggerConnection = nil
            end
            return
        end

        -- Ensure no-clip is active for non-humanoid parts during the follow
        if not isNoclipActive then
            enableNoclip(character)
        end

        if elapsedTime >= duration then
            if connections.daggerConnection then
                connections.daggerConnection:Disconnect()
                connections.daggerConnection = nil
            end
            playerHumanoidRootPart.CFrame = originalCFrame
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Teleported back after 1 second!")
            return
        end

        if not killer.Character or not killer.Character:FindFirstChild("HumanoidRootPart") then
            warn("Killer's HumanoidRootPart lost during follow!")
            if connections.daggerConnection then
                connections.daggerConnection:Disconnect()
                connections.daggerConnection = nil
            end
            playerHumanoidRootPart.CFrame = originalCFrame
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Teleported back due to killer loss!")
            return
        end

        killerHumanoidRootPart = killer.Character.HumanoidRootPart
        killerPos = killerHumanoidRootPart.Position
        behindPos = killerHumanoidRootPart.CFrame * offset
        lookAtCFrame = CFrame.new(behindPos.Position, killerPos)
        playerHumanoidRootPart.CFrame = lookAtCFrame
    end)
end

-- WalkspeedOverride Ability Functions
local function useWalkspeedAbility()
    if abilityDebounce then return false end
    local character = LocalPlayer.Character
    if not character or character.Name ~= "c00lkidd" then
        warn("Player character is not c00lkidd!")
        return false
    end
    abilityDebounce = true
    task.defer(function() task.wait(ABILITY_DEBOUNCE_TIME) abilityDebounce = false end)
    local args = { "UseActorAbility", "WalkspeedOverride" }
    if RemoteEvent:IsA("RemoteEvent") then
        RemoteEvent:FireServer(unpack(args))
        print("Instantly used WalkspeedOverride ability!")
        return true
    else
        Rayfield:Notify{Title = "Error", Content = "RemoteEvent not found!", Duration = 5}
        return false
    end
end

local function teleportCloseToSurvivor()
    if not walkspeedEnabled or teleportDebounce then return end
    teleportDebounce = true
    task.defer(function() task.wait(DEBOUNCE_TIME) teleportDebounce = false end)

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or character.Name ~= "c00lkidd" then
        warn("Player character or HumanoidRootPart not found or not c00lkidd!")
        return
    end

    local playerHumanoidRootPart = character.HumanoidRootPart
    local survivor = findClosestSurvivor()
    if not survivor or not survivor.Character or not survivor.Character:FindFirstChild("HumanoidRootPart") then
        warn("Survivor or survivor character not found!")
        return
    end

    if not useWalkspeedAbility() then return end
    task.wait(0.1)

    enableNoclip(character)

    local survivorHumanoidRootPart = survivor.Character.HumanoidRootPart
    local offset = CFrame.new(0, 0, 0.25)
    local survivorPos = survivorHumanoidRootPart.Position
    local closePos = survivorHumanoidRootPart.CFrame * offset
    local lookAtCFrame = CFrame.new(closePos.Position, survivorPos)
    playerHumanoidRootPart.CFrame = lookAtCFrame
    print("Teleported 0.25 studs behind the closest survivor and facing them!")

    local elapsedTime = 0
    local duration = 1
    if connections.walkspeedConnection then
        connections.walkspeedConnection:Disconnect()
    end
    connections.walkspeedConnection = RunService.Heartbeat:Connect(function(deltaTime)
        elapsedTime = elapsedTime + deltaTime
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            if connections.walkspeedConnection then
                connections.walkspeedConnection:Disconnect()
                connections.walkspeedConnection = nil
            end
            return
        end

        -- Ensure no-clip is active for non-humanoid parts during the follow
        if not isNoclipActive then
            enableNoclip(character)
        end

        if elapsedTime >= duration then
            if connections.walkspeedConnection then
                connections.walkspeedConnection:Disconnect()
                connections.walkspeedConnection = nil
            end
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Finished following survivor after 1 second!")
            return
        end

        if not survivor.Character or not survivor.Character:FindFirstChild("HumanoidRootPart") then
            warn("Survivor's HumanoidRootPart lost during follow!")
            if connections.walkspeedConnection then
                connections.walkspeedConnection:Disconnect()
                connections.walkspeedConnection = nil
            end
            -- Only disable no-clip if no other abilities are active
            if not (slashEnabled or daggerEnabled or walkspeedEnabled or gashingWoundEnabled) then
                disableNoclip(character)
            end
            print("Stopped following due to survivor loss!")
            return
        end

        survivorHumanoidRootPart = survivor.Character.HumanoidRootPart
        survivorPos = survivorHumanoidRootPart.Position
        closePos = survivorHumanoidRootPart.CFrame * offset
        lookAtCFrame = CFrame.new(closePos.Position, survivorPos)
        playerHumanoidRootPart.CFrame = lookAtCFrame
    end)
end

-- Monitor Ability Usage
local function monitorAbilities()
    if RemoteEvent:IsA("RemoteEvent") then
        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local args = {...}
            if self == RemoteEvent and getnamecallmethod() == "FireServer" and args[1] == "UseActorAbility" then
                if args[2] == "Slash" and slashEnabled and LocalPlayer.Character and LocalPlayer.Character.Name == "Shedletsky" then
                    slashAndTeleport()
                elseif args[2] == "Dagger" and daggerEnabled and LocalPlayer.Character and LocalPlayer.Character.Name == "TwoTime" then
                    teleportBehindKiller()
                elseif args[2] == "WalkspeedOverride" and walkspeedEnabled and LocalPlayer.Character and LocalPlayer.Character.Name == "c00lkidd" then
                    teleportCloseToSurvivor()
                elseif args[2] == "GashingWound" and gashingWoundEnabled and LocalPlayer.Character and LocalPlayer.Character.Name == "Jason" then
                    teleportCloseToSurvivorGashingWound()
                end
            end
            return oldNamecall(self, ...)
        end)
    else
        Rayfield:Notify{Title = "Error", Content = "RemoteEvent not found for ability monitoring!", Duration = 5}
    end
end

monitorAbilities()

-- GUI Functions
local function waitForTopbar()
    local gui = LocalPlayer:WaitForChild("PlayerGui")
    repeat task.wait() until gui:FindFirstChild("TopbarStandard")
    local topbar = gui:WaitForChild("TopbarStandard")
    return topbar:WaitForChild("Holders"):WaitForChild("Left")
end

local leftBar = waitForTopbar()

local button = Instance.new("TextButton")
button.Name = "RayfieldToggle"
button.Size = UDim2.new(0, 146, 0.8, 0)
button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
button.BackgroundTransparency = 0.3
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.Font = Enum.Font.Gotham
button.TextSize = 20
button.Text = "Toggle UI"
button.LayoutOrder = 10
button.Parent = leftBar

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 30)
corner.Parent = button

-- Set initial size based on text bounds
button.Size = UDim2.new(0, button.TextBounds.X + 20, 0.8, 0)

local visible = true
button.MouseButton1Click:Connect(function()
    visible = not visible
    Rayfield:SetVisibility(visible, false)
end)

if leftBar:FindFirstChild("RayfieldToggle") then
    leftBar.RayfieldToggle:Destroy()
end

local survivorutil = { "007n7", "BuildermanSentry", "BuildermanDispenser", "Pizza" }

local function toggleHighlightGen(state)
    isHighlightActive = state
    if not state and connections.genConnection then
        connections.genConnection:Disconnect()
        connections.genConnection = nil
    end

    local function applyGeneratorHighlight(generator)
        if generator.Name ~= "Generator" then return end
        local existingHighlight = generator:FindFirstChild("GeneratorHighlight")
        local progress = generator:FindFirstChild("Progress")
        if isHighlightActive then
            if not existingHighlight then
                local genhighlight = Instance.new("Highlight")
                genhighlight.Parent = generator
                genhighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                genhighlight.Name = "GeneratorHighlight"
            end
        elseif existingHighlight then
            existingHighlight:Destroy()
            return
        end
        if progress and progress.Value == 100 then
            if existingHighlight then existingHighlight:Destroy() end
            return
        end
        if progress and isHighlightActive then
            connections["progress_" .. generator:GetFullName()] = progress:GetPropertyChangedSignal("Value"):Connect(function()
                if progress.Value == 100 then
                    local highlight = generator:FindFirstChild("GeneratorHighlight")
                    if highlight then highlight:Destroy() end
                elseif isHighlightActive and not generator:FindFirstChild("GeneratorHighlight") then
                    local genhighlight = Instance.new("Highlight")
                    genhighlight.Parent = generator
                    genhighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    genhighlight.Name = "GeneratorHighlight"
                end
            end)
        end
    end

    for _, v in ipairs(MapIngame:WaitForChild("Map"):GetChildren()) do
        applyGeneratorHighlight(v)
    end
    if state then
        connections.genConnection = MapIngame.Map.ChildAdded:Connect(applyGeneratorHighlight)
    end
end

local function togglehidebar(state)
    hideplayerbar = state
    local playerinfo = LocalPlayer.PlayerGui:WaitForChild("TemporaryUI"):WaitForChild("PlayerInfo")
    playerinfo.CurrentSurvivors.Visible = not hideplayerbar
    if hideplayerbar then
        playerinfo.PlayerIcon.Image = "rbxassetid://12549056837"
    end
end

local function Do1x1x1x1Popups()
    while Do1x1PopupsLoop do
        local popups = LocalPlayer.PlayerGui:WaitForChild("TemporaryUI"):GetChildren()
        for _, popup in ipairs(popups) do
            if popup.Name == "1x1x1x1Popup" then
                local centerX = popup.AbsolutePosition.X + (popup.AbsoluteSize.X / 2)
                local centerY = popup.AbsolutePosition.Y + (popup.AbsoluteSize.Y / 2)
                VIM:SendMouseButtonEvent(centerX, centerY, Enum.UserInputType.MouseButton1.Value, true, LocalPlayer.PlayerGui, 1)
                VIM:SendMouseButtonEvent(centerX, centerY, Enum.UserInputType.MouseButton1.Value, false, LocalPlayer.PlayerGui, 1)
            end
        end
        task.wait(0.2)
    end
end

local function solvegen()
    for _, v in ipairs(MapIngame:WaitForChild("Map"):GetChildren()) do
        if v.Name == "Generator" then
            local remotes = v:WaitForChild("Remotes")
            local re = remotes:WaitForChild("RE")
            re:FireServer()
        end
    end
end

local function highlighttools(state)
    toolhighlightActive = state
    if not state and connections.toolConnection then
        connections.toolConnection:Disconnect()
        connections.toolConnection = nil
    end

    local function applyHighlight(tool)
        if not tool:IsA("Tool") then return end
        local existinghighlight = tool:FindFirstChild("ToolHighlight")
        if toolhighlightActive then
            if not existinghighlight then
                local toolhighlight = Instance.new("Highlight")
                toolhighlight.Name = "ToolHighlight"
                toolhighlight.Parent = tool
                toolhighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                if tool.Name == "Medkit" then
                    toolhighlight.FillColor = Color3.fromRGB(0, 255, 0)
                elseif tool.Name == "BloxyCola" then
                    toolhighlight.FillColor = Color3.fromRGB(88, 57, 39)
                end
            end
        elseif existinghighlight then
            existinghighlight:Destroy()
        end
    end

    for _, v in ipairs(MapIngame:GetChildren()) do
        applyHighlight(v)
    end
    if state then
        connections.toolConnection = MapIngame.ChildAdded:Connect(applyHighlight)
    end
end

local function coolkidesp(state)
    isCorruptNatureEspActive = state
    local validNames = { ["HumanoidRootProjectile"] = true, ["PizzaDeliveryRig"] = true, ["Bunny"] = true, ["Mafiaso1"] = true, ["Mafiaso2"] = true, ["Mafiaso3"] = true }
    for _, v in ipairs(MapIngame:GetChildren()) do
        if v:IsA("Model") and validNames[v.Name] then
            local existingHighlight = v:FindFirstChild("CorruptNatureHighlight")
            if isCorruptNatureEspActive and not existingHighlight then
                local highlight = Instance.new("Highlight")
                highlight.Name = "CorruptNatureHighlight"
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = v
            elseif not isCorruptNatureEspActive and existingHighlight then
                existingHighlight:Destroy()
            end
        end
    end
end

local function survivorutilesp(state)
    isSurvivorUtilEspActive = state
    if not state and connections.utilConnection then
        connections.utilConnection:Disconnect()
        connections.utilConnection = nil
    end

    local function applySurvivorUtilHighlight(model)
        if not (model:IsA("Model") or model:IsA("Part")) then return end
        local existingHighlight = model:FindFirstChild("SurvivorUtilHighlight")
        if isSurvivorUtilEspActive then
            for _, util in ipairs(survivorutil) do
                if model.Name == util and not existingHighlight then
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "SurvivorUtilHighlight"
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.FillColor = Color3.fromRGB(255, 255, 255)
                    highlight.FillTransparency = 0.5
                    highlight.Parent = model
                    break
                end
            end
        elseif existingHighlight then
            existingHighlight:Destroy()
        end
    end

    for _, v in ipairs(MapIngame:GetChildren()) do
        applySurvivorUtilHighlight(v)
    end
    if state then
        connections.utilConnection = MapIngame.ChildAdded:Connect(applySurvivorUtilHighlight)
    end
end

local function survivorHighlighter(state)
    isSurvivorHighlightActive = state
    if not state and connections.survivorConnection then
        connections.survivorConnection:Disconnect()
        connections.survivorConnection = nil
    end

    local function applySurvivorHighlight(model)
        if not model:IsA("Model") or not model:FindFirstChild("Head") then return end
        local existingBillboard = model.Head:FindFirstChild("billboard")
        local existingHighlight = model:FindFirstChild("HiThere")
        if isSurvivorHighlightActive then
            if not existingBillboard then
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "billboard"
                billboard.Size = UDim2.new(0, 100, 0, 50)
                billboard.StudsOffset = Vector3.new(0, 2, 0)
                billboard.AlwaysOnTop = true
                billboard.Parent = model.Head
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.Text = model.Name
                textLabel.TextColor3 = Color3.new(1, 1, 1)
                textLabel.TextStrokeTransparency = 0
                textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Parent = billboard
            end
            if not existingHighlight then
                local highlight = Instance.new("Highlight")
                highlight.Name = "HiThere"
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.FillColor = Color3.fromRGB(0, 255, 0)
                highlight.Parent = model
            end
        else
            if existingBillboard then existingBillboard:Destroy() end
            if existingHighlight then existingHighlight:Destroy() end
        end
    end

    for _, v in ipairs(SurvivorsFolder:GetChildren()) do
        applySurvivorHighlight(v)
    end
    if state then
        connections.survivorConnection = SurvivorsFolder.ChildAdded:Connect(applySurvivorHighlight)
    end
end

local function killerHighlighter(state)
    isKillerHighlightActive = state
    if not state and connections.killerConnection then
        connections.killerConnection:Disconnect()
        connections.killerConnection = nil
    end

    local function applyKillerHighlight(model)
        if not model:IsA("Model") or not model:FindFirstChild("Head") then return end
        local existingBillboard = model.Head:FindFirstChild("billboard")
        local existingHighlight = model:FindFirstChild("HiThere")
        if isKillerHighlightActive then
            if not existingBillboard then
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "billboard"
                billboard.Size = UDim2.new(0, 100, 0, 50)
                billboard.StudsOffset = Vector3.new(0, 2, 0)
                billboard.AlwaysOnTop = true
                billboard.Parent = model.Head
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.Text = model.Name
                textLabel.TextColor3 = Color3.new(1, 0, 0)
                textLabel.TextStrokeTransparency = 0
                textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Parent = billboard
            end
            if not existingHighlight then
                local highlight = Instance.new("Highlight")
                highlight.Name = "HiThere"
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.FillColor = Color3.fromRGB(255, 0, 0)
                highlight.Parent = model
            end
        else
            if existingBillboard then existingBillboard:Destroy() end
            if existingHighlight then existingHighlight:Destroy() end
        end
    end

    for _, v in ipairs(KillersFolder:GetChildren()) do
        applyKillerHighlight(v)
    end
    if state then
        connections.killerConnection = KillersFolder.ChildAdded:Connect(applyKillerHighlight)
    end
end

local function infstam(state)
    stam = state
    local stamscript = require(ReplicatedStorage.Systems.Character.Game.Sprinting)
    if connections.stamConnection then
        connections.stamConnection:Disconnect()
    end
    if not stam then
        stamscript.StaminaLossDisabled = true
        return
    end
    connections.stamConnection = RunService.Heartbeat:Connect(function()
        stamscript.StaminaLossDisabled = function() end
    end)
end

local function doomskin()
    local character = LocalPlayer.Character
    if not character or character.Name ~= "Shedletsky" then
        Rayfield:Notify{Title = "Wrong Character", Content = "Your current character isn't Shedletsky!", Duration = 5}
        return
    end

    for _, v in ipairs(character:GetChildren()) do
        if v:IsA("Shirt") or v:IsA("Pants") then
            v:Destroy()
        end
    end

    local headband = Instance.new("Accessory")
    local shirt = Instance.new("Shirt")
    local pants = Instance.new("Pants")
    local tshirt = Instance.new("ShirtGraphic")
    local headbandhandle = Instance.new("Part")
    local headbandhandleattach = Instance.new("Attachment")
    local headbandweld = Instance.new("Weld")
    local headbandmesh = Instance.new("SpecialMesh")

    shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=1808496"
    pants.PantsTemplate = "http://www.roblox.com/asset/?id=1809861"
    tshirt.Graphic = "http://www.roblox.com/asset/?id=2426992"
    headbandhandle.Name = "Handle"
    headbandhandle.CanCollide = false
    headbandhandle.Color = Color3.fromRGB(27, 42, 53)
    headbandweld.Name = "AccessoryWeld"
    headbandweld.Part0 = headbandhandle
    headbandweld.Part1 = character.Head
    headbandweld.C0 = CFrame.new(0, -0.5, 0)
    headbandmesh.MeshId = "http://www.roblox.com/asset/?id=1286103"
    headbandmesh.TextureId = "rbxassetid://6858319251"
    headbandmesh.Scale = Vector3.new(0.992, 0.994, 0.992)
    headbandhandleattach.Name = "HatAttachment"
    headbandhandleattach.CFrame = CFrame.new(0, 0.557, 0)

    shirt.Parent = character
    pants.Parent = character
    tshirt.Parent = character
    headband.Parent = character
    headbandhandle.Parent = headband
    headbandhandleattach.Parent = headbandhandle
    headbandmesh.Parent = headbandhandle
    headbandweld.Parent = headbandhandle

    if character:FindFirstChild("ShedHair") then
        character.ShedHair:Destroy()
    end

    local playerinfo = LocalPlayer.PlayerGui:WaitForChild("TemporaryUI"):WaitForChild("PlayerInfo")
    playerinfo.PlayerIcon.Image = "http://www.roblox.com/asset/?id=118308385507069"
end

local function unlockclientcharacters()
    local equippedSkins = LocalPlayer.PlayerData.Equipped.Skins
    local clone = equippedSkins:Clone()
    clone.Parent = LocalPlayer.PlayerData.Purchased.Killers
    for _, v in ipairs(clone:GetChildren()) do
        v.Parent = LocalPlayer.PlayerData.Purchased.Killers
    end
    local clone2 = equippedSkins:Clone()
    clone2.Parent = LocalPlayer.PlayerData.Purchased.Survivors
    for _, v in ipairs(clone2:GetChildren()) do
        v.Parent = LocalPlayer.PlayerData.Purchased.Survivors
    end
end

local function flip()
    local character = LocalPlayer.Character
    if not character then return end
    local hum = character.Humanoid
    local animator = hum.Animator
    local hrp = character.HumanoidRootPart
    if animator then
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end
    end
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    hum:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    hum:SetStateEnabled(Enum.HumanoidStateType.Running, false)
    hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
    local duration = 0.45
    local steps = 120
    local startCFrame = hrp.CFrame
    local forwardVector = startCFrame.LookVector
    local upVector = Vector3.new(0, 1, 0)
    task.spawn(function()
        local startTime = tick()
        for i = 1, steps do
            local t = i / steps
            local height = 4 * (t - t ^ 2) * 10
            local nextPos = startCFrame.Position + forwardVector * (35 * t) + upVector * height
            local rotation = startCFrame.Rotation * CFrame.Angles(-math.rad(i * (360 / steps)), 0, 0)
            hrp.CFrame = CFrame.new(nextPos) * rotation
            local elapsedTime = tick() - startTime
            local expectedTime = (duration / steps) * i
            local waitTime = expectedTime - elapsedTime
            if waitTime > 0 then
                task.wait(waitTime)
            end
        end
        hrp.CFrame = CFrame.new(startCFrame.Position + forwardVector * 35) * startCFrame.Rotation
        hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
        hum:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
        hum:SetStateEnabled(Enum.HumanoidStateType.Running, true)
        hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
        hum:ChangeState(Enum.HumanoidStateType.Running)
    end)
end

local function FOVmulti(value)
    local camera = Workspace.CurrentCamera
    if camera then
        camera.FieldOfView = 70 * value
    end
end

-- Create Tabs
local Vtab = GUI:CreateTab("Visuals", "eye")
local Gtab = GUI:CreateTab("Generator", "archive")
local Stab = GUI:CreateTab("Survivors", "key")
local Btab = GUI:CreateTab("Blatant", "laugh")
local Mtab = GUI:CreateTab("Misc", "meh")

-- Visuals Tab
Vtab:CreateToggle({
   Name = "Generator ESP",
   CurrentValue = false,
   Callback = function(state)
       toggleHighlightGen(state)
   end
})

Vtab:CreateToggle({
   Name = "Item ESP",
   CurrentValue = false,
   Callback = function(state)
       highlighttools(state)
   end
})

Vtab:CreateToggle({
   Name = "Survivor ESP",
   CurrentValue = false,
   Callback = function(state)
       survivorHighlighter(state)
   end
})

Vtab:CreateToggle({
   Name = "Survivor Utility ESP",
   CurrentValue = false,
   Callback = function(state)
       survivorutilesp(state)
   end
})

Vtab:CreateToggle({
   Name = "Killer ESP",
   CurrentValue = false,
   Callback = function(state)
       killerHighlighter(state)
   end
})

Vtab:CreateToggle({
   Name = "c00lkidd Bot ESP",
   CurrentValue = false,
   Callback = function(state)
       coolkidesp(state)
   end
})

-- Survivors Tab
Stab:CreateToggle({
    Name = "Instant 1x1x1x1 Pop-Up",
    CurrentValue = false,
    Callback = function(state)
        Do1x1PopupsLoop = state
        if state then
            task.spawn(Do1x1x1x1Popups)
        end
    end
})

Stab:CreateToggle({
    Name = "Enable Slash Auto-Teleport",
    CurrentValue = false,
    Callback = function(state)
        slashEnabled = state
        Rayfield:Notify{Title = "Slash Auto-Teleport", Content = state and "Slash auto-teleport is now enabled!" or "Slash auto-teleport is now disabled!", Duration = 5}
    end
})

Stab:CreateToggle({
    Name = "Enable Dagger Auto-Teleport",
    CurrentValue = false,
    Callback = function(state)
        daggerEnabled = state
        Rayfield:Notify{Title = "Dagger Auto-Teleport", Content = state and "Dagger auto-teleport is now enabled!" or "Dagger auto-teleport is now disabled!", Duration = 5}
    end
})

Stab:CreateToggle({
    Name = "Enable Walkspeed Auto-Teleport",
    CurrentValue = false,
    Callback = function(state)
        walkspeedEnabled = state
        Rayfield:Notify{Title = "Walkspeed Auto-Teleport", Content = state and "Walkspeed auto-teleport is now enabled!" or "Walkspeed auto-teleport is now disabled!", Duration = 5}
    end
})

Stab:CreateToggle({
    Name = "Enable GashingWound Auto-Teleport",
    CurrentValue = false,
    Callback = function(state)
        gashingWoundEnabled = state
        Rayfield:Notify{Title = "GashingWound Auto-Teleport", Content = state and "GashingWound auto-teleport is now enabled!" or "GashingWound auto-teleport is now disabled!", Duration = 5}
    end
})

Stab:CreateDivider()

Stab:CreateButton({
    Name = "Doombringer Shedletsky Skin",
    Callback = function()
        doomskin()
    end
})

-- Generator Tab
Gtab:CreateButton({
   Name = "Instant Current Generator",
   CurrentValue = false,
   Callback = function()
       solvegen()
   end
})

Gtab:CreateKeybind({
    Name = "Instant Current Generator Keybind",
    CurrentKeybind = "H",
    HoldToInteract = false,
    Callback = function()
        solvegen()
    end
})

-- Blatant Tab
Btab:CreateToggle({
    Name = "Infinite Stamina",
    CurrentValue = false,
    Callback = function(state)
        infstam(state)
        Rayfield:Notify{Title = "Note:", Content = "Only works on Swift, Velocity, Delta, Codex and more.", Duration = 5}
    end
})

-- Misc Tab
Mtab:CreateToggle({
    Name = "Hide Player Bar",
    CurrentValue = false,
    Callback = function(state)
        togglehidebar(state)
    end
})

Mtab:CreateSlider({
    Name = "FOV",
    Range = {1, 2},
    Increment = 1,
    Suffix = ";",
    CurrentValue = 1,
    Callback = function(value)
        FOVmulti(value)
    end
})

Mtab:CreateButton({
   Name = "Unlock Everything (Visual)",
   CurrentValue = false,
   Callback = function()
       unlockclientcharacters()
   end
})

Mtab:CreateKeybind({
    Name = "Frontflip",
    CurrentKeybind = "Z",
    HoldToInteract = false,
    Callback = function()
        flip()
    end
})

Mtab:CreateDivider()

Mtab:CreateButton({
   Name = "Set Device PC",
   CurrentValue = false,
   Callback = function()
       RemoteEvent:FireServer("SetDevice", "PC")
   end
})

Mtab:CreateButton({
   Name = "Set Device Mobile",
   CurrentValue = false,
   Callback = function()
       RemoteEvent:FireServer("SetDevice", "Mobile")
   end
})

Mtab:CreateButton({
   Name = "Set Device Console",
   CurrentValue = false,
   Callback = function()
       RemoteEvent:FireServer("SetDevice", "Console")
   end
})

Mtab:CreateButton({
   Name = "Set Device Unknown",
   CurrentValue = false,
   Callback = function()
       RemoteEvent:FireServer("SetDevice", "Unknown")
   end
})
